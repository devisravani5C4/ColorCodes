<!DOCTYPE html>
<html lang="en" >
<head>
  <meta charset="UTF-8" />
  <title>Color Codes Picker - Pixel Color Fix</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      background: #f5f5f5;
      padding: 30px;
      display: flex;
      flex-direction: column;
      align-items: center;
      user-select: none;
    }
    h1 {
      margin-bottom: 25px;
    }
    .picker-container {
      display: flex;
      gap: 30px;
      align-items: center;
    }
    /* Vertical Hue slider */
    #hueCanvas {
      border: 1px solid #ccc;
      cursor: pointer;
      position: relative;
      width: 50px;
      height: 300px;
      border-radius: 8px;
      box-shadow: 0 0 6px #aaa inset;
    }
    /* Saturation-Lightness square */
    #slCanvas {
      border: 1px solid #ccc;
      cursor: crosshair;
      width: 300px;
      height: 300px;
      border-radius: 8px;
      box-shadow: 0 0 6px #aaa inset;
      position: relative;
    }
    /* Selector circles (smaller now) */
    .selector {
      position: absolute;
      border: 2px solid white;
      border-radius: 50%;
      box-shadow: 0 0 5px #0006;
      pointer-events: none;
      width: 14px;
      height: 14px;
      transform: translate(-50%, -50%);
      background: none;
      z-index: 10;
    }
    #hueSelector {
      left: 50%;
      top: 0;
      cursor: grab;
    }
    #slSelector {
      width: 16px;
      height: 16px;
      border: 2px solid white;
      box-shadow: 0 0 6px #0008;
      background: none;
      cursor: grab;
    }
    /* Info panel */
    .info {
      margin-top: 25px;
      background: white;
      padding: 20px 40px;
      border-radius: 10px;
      box-shadow: 0 0 10px #aaa;
      font-size: 18px;
      display: flex;
      align-items: center;
      gap: 30px;
      min-width: 380px;
      justify-content: center;
      flex-wrap: wrap;
      text-align: left;
    }
    .color-swatch {
      width: 70px;
      height: 70px;
      border-radius: 8px;
      border: 2px solid #333;
      box-shadow: inset 0 0 8px #0004;
    }
    .info div {
      min-width: 140px;
    }
  </style>
</head>
<body>

<h1>Color Codes Picker</h1>

<div class="picker-container">
  <div style="position: relative;">
    <canvas id="hueCanvas" width="50" height="300"></canvas>
    <div id="hueSelector" class="selector"></div>
  </div>
  <div style="position: relative;">
    <canvas id="slCanvas" width="300" height="300"></canvas>
    <div id="slSelector" class="selector"></div>
  </div>
</div>

<div class="info">
  <div><b>RGB:</b> <span id="rgb">-</span></div>
  <div><b>HSL:</b> <span id="hsl">-</span></div>
  <div><b>Hex:</b> <span id="hex">-</span></div>
  <div class="color-swatch" id="colorSwatch"></div>
</div>

<script>
  const hueCanvas = document.getElementById('hueCanvas');
  const slCanvas = document.getElementById('slCanvas');
  const hueCtx = hueCanvas.getContext('2d');
  const slCtx = slCanvas.getContext('2d');

  const hueSelector = document.getElementById('hueSelector');
  const slSelector = document.getElementById('slSelector');

  const rgbSpan = document.getElementById('rgb');
  const hslSpan = document.getElementById('hsl');
  const hexSpan = document.getElementById('hex');
  const colorSwatch = document.getElementById('colorSwatch');

  const hueWidth = hueCanvas.width;
  const hueHeight = hueCanvas.height;

  const slWidth = slCanvas.width;
  const slHeight = slCanvas.height;

  let currentHue = 0;
  let currentSat = 100;
  let currentLight = 50;

  // Draw vertical hue gradient (original)
  function drawHueGradient() {
    const hueGradient = hueCtx.createLinearGradient(0, 0, 0, hueHeight);
    for(let i=0; i<=360; i+=10) {
      hueGradient.addColorStop(i/360, `hsl(${i}, 100%, 50%)`);
    }
    hueCtx.fillStyle = hueGradient;
    hueCtx.fillRect(0, 0, hueWidth, hueHeight);
  }

  // Original SL square (two overlapping gradients)
  function drawSaturationLightnessSquare(hue) {
    // Fill with hue color, lightness 50%, saturation 100%
    slCtx.fillStyle = `hsl(${hue}, 100%, 50%)`;
    slCtx.fillRect(0, 0, slWidth, slHeight);

    // White gradient (left to right) for saturation
    const whiteGradient = slCtx.createLinearGradient(0, 0, slWidth, 0);
    whiteGradient.addColorStop(0, 'rgba(255,255,255,1)');
    whiteGradient.addColorStop(1, 'rgba(255,255,255,0)');
    slCtx.fillStyle = whiteGradient;
    slCtx.fillRect(0, 0, slWidth, slHeight);

    // Black gradient (top to bottom) for lightness
    const blackGradient = slCtx.createLinearGradient(0, 0, 0, slHeight);
    blackGradient.addColorStop(0, 'rgba(0,0,0,0)');
    blackGradient.addColorStop(1, 'rgba(0,0,0,1)');
    slCtx.fillStyle = blackGradient;
    slCtx.fillRect(0, 0, slWidth, slHeight);
  }

  // RGB to Hex conversion
  function rgbToHex(r, g, b) {
    return "#" + [r, g, b].map(x => {
      const hex = x.toString(16);
      return hex.length === 1 ? "0" + hex : hex;
    }).join('');
  }

  // RGB to HSL conversion
  function rgbToHsl(r, g, b) {
    r /= 255; g /= 255; b /= 255;
    const max = Math.max(r, g, b), min = Math.min(r, g, b);
    let h = 0, s = 0;
    const l = (max + min) / 2;

    if (max !== min) {
      const d = max - min;
      s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
      switch(max) {
        case r: h = (g - b) / d + (g < b ? 6 : 0); break;
        case g: h = (b - r) / d + 2; break;
        case b: h = (r - g) / d + 4; break;
      }
      h *= 60;
    }

    return [h, s * 100, l * 100];
  }

  // Update displayed color info and swatch with exact RGB and HSL
  function updateColorInfoRGB(r, g, b) {
    const [h, s, l] = rgbToHsl(r, g, b);
    rgbSpan.textContent = `${r}, ${g}, ${b}`;
    hslSpan.textContent = `${Math.round(h)}, ${Math.round(s)}, ${Math.round(l)}`;
    hexSpan.textContent = rgbToHex(r, g, b);
    colorSwatch.style.backgroundColor = `rgb(${r},${g},${b})`;
  }

  // Position selectors exactly on canvas based on H, S, L values (floats)
  function positionHueSelector(hue) {
    const y = (hue / 360) * hueHeight;
    hueSelector.style.top = `${y}px`;
  }
  function positionSLSelector(sat, light) {
    const x = (sat / 100) * slWidth;
    const y = ((100 - light) / 100) * slHeight;
    slSelector.style.left = `${x}px`;
    slSelector.style.top = `${y}px`;
  }

  // Get pixel color at given (x,y) on SL canvas
  function getSLPixelColor(x, y) {
    x = Math.min(Math.max(Math.round(x), 0), slWidth - 1);
    y = Math.min(Math.max(Math.round(y), 0), slHeight - 1);
    const pixel = slCtx.getImageData(x, y, 1, 1).data;
    return [pixel[0], pixel[1], pixel[2]];
  }

  // Initial draw and positioning
  drawHueGradient();
  drawSaturationLightnessSquare(currentHue);
  positionHueSelector(currentHue);
  positionSLSelector(currentSat, currentLight);

  // Get initial color from SL canvas pixel to display correct swatch
  let initialX = (currentSat / 100) * slWidth;
  let initialY = ((100 - currentLight) / 100) * slHeight;
  let [r, g, b] = getSLPixelColor(initialX, initialY);
  updateColorInfoRGB(r, g, b);

  let draggingHue = false;
  let draggingSL = false;

  // Hue dragging handlers
  hueCanvas.addEventListener('mousedown', e => {
    draggingHue = true;
    updateHue(e);
  });
  window.addEventListener('mouseup', () => draggingHue = false);
  window.addEventListener('mousemove', e => {
    if(draggingHue) updateHue(e);
  });

  // SL dragging handlers
  slCanvas.addEventListener('mousedown', e => {
    draggingSL = true;
    updateSL(e);
  });
  window.addEventListener('mouseup', () => draggingSL = false);
  window.addEventListener('mousemove', e => {
    if(draggingSL) updateSL(e);
  });

  // Hue update - redraw SL palette and reposition selectors
  function updateHue(e) {
    const rect = hueCanvas.getBoundingClientRect();
    let y = e.clientY - rect.top;
    y = Math.min(Math.max(y, 0), hueHeight);
    currentHue = (y / hueHeight) * 360;
    positionHueSelector(currentHue);
    drawSaturationLightnessSquare(currentHue);

    // After redraw, get pixel color at current SL selector pos
    let x = (currentSat / 100) * slWidth;
    let ySL = ((100 - currentLight) / 100) * slHeight;
    const [r, g, b] = getSLPixelColor(x, ySL);
    updateColorInfoRGB(r, g, b);
  }

  // SL update - update selector position and get exact pixel color from SL canvas
  function updateSL(e) {
    const rect = slCanvas.getBoundingClientRect();
    let x = e.clientX - rect.left;
    let y = e.clientY - rect.top;
    x = Math.min(Math.max(x, 0), slWidth);
    y = Math.min(Math.max(y, 0), slHeight);

    currentSat = (x / slWidth) * 100;
    currentLight = 100 - (y / slHeight) * 100;

    positionSLSelector(currentSat, currentLight);

    // Read pixel color directly under the selector circle for perfect match
    const [r, g, b] = getSLPixelColor(x, y);
    updateColorInfoRGB(r, g, b);
  }

  // Allow clicking to set hue and SL immediately
  hueCanvas.addEventListener('click', updateHue);
  slCanvas.addEventListener('click', updateSL);

</script>

</body>
</html>
